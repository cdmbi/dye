bio <- as.character(packages$Bioconductor)
library(RCurl)
x <- getURL("https://raw.githubusercontent.com/Rnewbie/OliFP/master/packages_to_be_install.csv")
packages <- read.csv(text=x, header = TRUE)
bio <- as.character(packages$Bioconductor)
source("http://bioconductor.org/biocLite.R")
biocLite(bio)
library(protr)
library(readxl)
library(Caret)
library(Biostrings)
library(RWeka)
library(dplyr)
library(e1071)
library(randomForest)
library(nnet)
library(caret)
library(Biostrings)
library(Rcpi)
source("http://bioconductor.org/biocLite.R")
biocLite("Rcpi")
library(Rcpi)
library(rJava)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jre7')
library(rJava)
library(rJava)
library(Rhipe)
install.packages("Rhipe")
library(rJava)
library(RJSONIO)
library(itertools)
install.packages("itertools")
## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("BioSeqClass")
library(GioSeqClass)
library(BioSeqClass)
?hr
?cdhitHR
install.packages(c('rzmq','repr','IRkernel','IRdisplay'),
repos = c('http://irkernel.github.io/', getOption('repos')))
IRkernel::installspec()
data(iris)
library(rJava)
Sys.getenv("JAVA_HOME")
Sys.setenv(JAVA_HOME = "C:\\Program Files/Java/jre1.8.0_65/")
library(rJava)
130 - 1 - 62 - 35
# the value for B4 is:
130 - 32 - 35 - 34
# the value for C2 is:
130 - 62 - 35 - 2
# the value for c3 is:
130 - 36 - 31 - 33
# the value for D4 is:
130 - 1 - 35 - 30
# the value for A3 is:
130 - 61 - 2 - 64
# the value for A4 is:
date()
# the value for A4 is:
130 - 1 - 62 - 63
# isolate a signal column within a dataset using the varialbe$column notation.
#display the contents of the Soldiers column from the soldiersByCity variable
newvec = 25:45
## Make a single time-series for annual, quarterly, and monthly data
ts(newvec, start = 1965)  # annual
ts(newvec, start = 2965, frequency = 4)
ts(newvec, start = 1965, frequency = 12) # monthly
## Make a matrix
mat = matrix(1:60, nrow = 12)
# Make a multiple time-series object, monthly data
ts(mat, start = 1955, frequency = 12)
## New logical vector
vector(mode = "logical", length = 3)
## New numeric vector
vector(mode = "numeric", length = 3)
## New character vector
vector(mode = "character", length = 3)
## New list object
vector(mode = "list", length = 3)
## Make simple data vector
sample = c(1.2, 2.4, 3.1, 4, 2.7)
## Make into integer valeus
as.integer(sample)
## Make into characters
as.character(sample)
as.list(sample)
## Make a matrix of numbers
matdata = matrix(1:12, ncol = 4)
## Coerce to a table
as.table(matdata)
library(rJava)
if (Sys.getenv("JAVA_HOME")!="")
Sys.setenv(JAVA_HOME="")
library(rJava)
library(rjava)
library(rJava)
Sys.setenv(JAVA_HOME)
library(rJava)
library(RWeka)
library(rJava)
library(rJava)
library(rJava)
library(protr)
library(rJava)
system("java -version")
library(BioSeqClass)
aa.index
View(aa.index)
str(aa.index)
library(rJava)
setwd("C:/Users/Saw/Downloads/dye")
read_file <- function(x){
library(caret)
library(data.table)
data <- fread(x)
data <- as.data.frame(data)
descriptors <- data[, 2:ncol(data)]
set.seed(1)
filtered_descriptors <- descriptors[, -nearZeroVar(descriptors)]
Activity <- data$Activity
filtered_data <- cbind(Activity, filtered_descriptors)
return(filtered_data)
}
AtomPairs2D_fingerPrintCount <- read_file("AtomPairs2DFingerprintCount.csv")
AtomPairs2D_fingerPrinter <- read_file("AtomPairs2DFingerprinter.csv")
Substructure_fingerPrintCount <- read_file("substructure_fingerprint.csv")
Substructure_fingerPrinter <- read_file("substructure_fingerprint.csv")
Extended_finterPrinter <- read_file("extended_finger_printer.csv")
FingerPrinter <- read_file("finger_printer.csv")
Estate_FingerPrinter <- read_file("estate_fingerprint.csv")
GraphOnly_FingerPrinter <- read_file("graph_only_fingerprint.csv")
KlekotaRoth_FingerprintCount <- read_file("KlekotaRothFingerprintCount.csv")
KlekotaRoth_FingerPrinter <- read_file("KlekotaRothFingerprinter.csv")
MACCS_FingerPrinter <- read_file("MACCS_finger_printer.csv")
Pubchem_FingerPrinter <- read_file("Pubchem_finger_printer.csv")
input <- list(AtomPairs2D_fingerPrintCount=AtomPairs2D_fingerPrintCount,
AtomPairs2D_fingerPrinter = AtomPairs2D_fingerPrinter,
Substructure_fingerPrintCount = Substructure_fingerPrintCount,
Substructure_fingerPrinter = Substructure_fingerPrinter,
Extended_finterPrinter = Extended_finterPrinter,
FingerPrinter = FingerPrinter,
Estate_FingerPrinter = Estate_FingerPrinter,
GraphOnly_FingerPrinter = GraphOnly_FingerPrinter,
KlekotaRoth_FingerprintCount = KlekotaRoth_FingerprintCount,
KlekotaRoth_FingerPrinter = KlekotaRoth_FingerPrinter,
MACCS_FingerPrinter = MACCS_FingerPrinter,
Pubchem_FingerPrinter = Pubchem_FingerPrinter)
RF_10_CV <- function(x){
library(parallel)
library(doSNOW)
cl <- makeCluster(8)
registerDoSNOW(cl)
ok <- list(100)
ok <- foreach(i = 1:100, .packages = 'randomForest') %dopar% {
data <- x
#trainIndex <- caret::createDataPartition(data$Activity, p = .8,
#                                        list = FALSE, times = 1)
# train_control <- caret::trainControl(method="LOOCV")
# train the model
model <- randomForest::randomForest(Activity~., data = data)
#model <- caret::train(Activity~., data=data, trControl=train_control, method="rf")
prediction <- predict(model, data)
actual <- data$Activity
results <- caret::confusionMatrix(prediction, actual)
results <- results$table
results <- as.numeric(results)
rm(data)
rm(model)
rm(prediction)
rm(myData)
rm(actual)
ok[[i]] <- results
}
return(ok)
stopCluster(cl)
}
mean_and_sd <- function(x) {
c(round(mean(x, na.rm = TRUE), digits = 2),
round(sd(x, na.rm = TRUE), digits = 2))
}
RF_10_cross_validation <- function(x) {
ok <- RF_10_CV(x)
results <- data.frame(ok)
rm(ok)
data <- data.frame(results)
rm(results)
m = ncol(data)
ACC  <- matrix(nrow = m, ncol = 1)
SENS  <- matrix(nrow = m, ncol = 1)
SPEC  <-matrix(nrow = m, ncol = 1)
MCC <- matrix(nrow = m, ncol = 1)
for(i in 1:m){
ACC[i,1]  = (data[1,i]+data[4,i])/(data[1,i]+data[2,i]+data[3,i]+data[4,i])*100
SENS[i,1]  =  (data[4,i])/(data[3,i]+data[4,i])*100
SPEC[i,1]  = (data[1,i]/(data[1,i]+data[2,i]))*100
MCC1      = (data[1,i]*data[4,i]) - (data[2,i]*data[3,i])
MCC2      =  (data[4,i]+data[2,i])*(data[4,i]+data[3,i])
MCC3      =  (data[1,i]+data[2,i])*(data[1,i]+data[3,i])
MCC4  =  sqrt(MCC2)*sqrt(MCC3)
MCC[i,1]  = MCC1/MCC4
}
results_ACC <- mean_and_sd(ACC)
results_SENS <- mean_and_sd(SENS)
results_SPEC <- mean_and_sd(SPEC)
results_MCC <- mean_and_sd(MCC)
rm(ACC)
rm(SENS)
rm(SPEC)
rm(MCC)
results_all <- (data.frame(c(results_ACC, results_SENS, results_SPEC, results_MCC)))
rownames(results_all) <- c("ACC_Mean", "ACC_SD", "Sens_Mean", "Sens_SD", "Spec_Mean", "Spec_SD",
"MCC_Mean", "MCC_SD")
return(results_all)
}
cross_validation_results_classification <- lapply(input, function(x) {
results <- RF_10_cross_validation(x)
return(results)
})
cross_validation_results_classification
